#
#ecProjects.defs -  definitions for ecProjects object.
#

#allows us to run stand-alone:
%ifndef CG_ROOT %include ../build_setup.defs

{ ## header section
PL_PACKAGE = $ECPROJECTS_PACKAGE
PL_PACKAGE_DESCRIPTION = collection of EC Projects

#not a base class - use standard constuctor name:
PL_CONSTRUCTOR_NAME = new

{
PL_EXTERN_PKG_IMPORTS = << (
)
PL_PKG_IMPORTS = << (
use $_ECPROJECT_PACKAGE;
)
%if    $GEN_ONE_MODULE   PL_PKG_IMPORTS = $PL_EXTERN_PKG_IMPORTS
%ifnot $GEN_ONE_MODULE   PL_PKG_IMPORTS = $PL_EXTERN_PKG_IMPORTS$PL_PKG_IMPORTS
}

PL_PKG_ATTRIBUTES := << (
#standard debugging attributes:
my ($VERBOSE, $DEBUG, $DDEBUG, $QUIET) = (0,0,0,0);
)
%evalmacro PL_PKG_ATTRIBUTES PL_PKG_ATTRIBUTES

####
#add to ATTRIBUTE_LIST as required.
#templates are: (r/w) pl_getset, pl_getsetlist; (r/o) pl_attr_method, pl_attrlist_method
####
ATTRIBUTE_LIST := << (
#debugging and verbosity levels, inherited from impl (r/w):
Debug	pl_getset	$cfg->getDebug()
DDebug	pl_getset	$cfg->getDDebug()
Quiet	pl_getset	$cfg->getQuiet()
Verbose	pl_getset	$cfg->getVerbose()
#sqlpj interface (r/o):
Sqlpj	pl_attr_method	$cfg->sqlpj()
#project attributes, inherited from impl:
OutputDirectory	pl_attr_method	$cfg->outputDirectory()
#local project attributes:
#reference to list of project objects (initially empty list):
EcProjects	pl_attrlist_method	undef
)
#generate attribute accessors (this creates class_attribute_dcls, getset_methods):
%include perl/genattr.defs
%call generate_attribute_accessors
}
{ ## constructor section
PL_CONSTRUCTOR_BODY := << (
my ($cfg) = @_;
)
%evalmacro PL_CONSTRUCTOR_BODY PL_CONSTRUCTOR_BODY

PL_OBJ_ATTRIBUTES := << (
{=class_attribute_dcls=}
)
%evalmacro PL_OBJ_ATTRIBUTES PL_OBJ_ATTRIBUTES

#this is for further initialzation of attributes, since hash init cannot be self-referential:
PL_POST_ATTRIBUTE_INIT := << (

#cache initial debugging and vebosity values in local package variables:
$self->update_static_class_attributes();
)
%evalmacro PL_POST_ATTRIBUTE_INIT PL_POST_ATTRIBUTE_INIT
}

PL_UPDATE_CLASS_STATIC_ATTRIBUTES := << (
$DEBUG   = $self->getDebug();
$DDEBUG  = $self->getDDebug();
$QUIET   = $self->getQuiet();
$VERBOSE = $self->getVerbose();
)

{ ## class methods

PL_PKG_METHODS := << (

sub addOneProject
#add a single project to the collection.
{
    my ($self, $projectName) = @_;

    #no setter, for mEcProjects - so use direct ref:
    push @{$self->{'mEcProjects'}}, (new {=_ECPROJECT_PACKAGE=}($self, $projectName));

    #TODO:  add project-level properties

    return 0;
}

sub addAllProjects
#add all of the EC projects to the collection.
#returns 0 on success
{
    my ($self) = @_;
    my ($sqlpj) = $self->sqlpj();

    my $lbuf = "select name from ec_project";

    if ( !$sqlpj->sql_exec($lbuf) ) {
        printf STDERR "%s:  ERROR:  all projects query failed.\n", ::srline();
        return 1;
    }

    #o'wise, stash results (query returns a ref to a list of list refs):
    my @projectlist = map {
        @{$_};    #dereference each row
    } @{$sqlpj->getQueryResult()};

    #now add one project obj. per retrieved project:
    for my $name (@projectlist) {
        $self->addOneProject($name);
    }

    return 0;
}

sub listProjectNames
#display the current list of project names
{
    my ($self) = @_;

    for my $pj ($self->ecProjects()) {
        printf "%s\n", $pj->projectName();
    }
}

sub dumpProjects
#dump each project to the dump tree.
{
    my ($self) = @_;

    for my $pj ($self->ecProjects()) {
        $pj->dumpProject();
    }
}

{=getset_methods=}

sub update_static_class_attributes
#static class method to update package level attributess as required
#used to set verbosity and debugging for all objects of the class post-instantiation.
{
    my ($self) = @_;
{=$PL_UPDATE_CLASS_STATIC_ATTRIBUTES:indent=}
}
)

%evalmacro PL_PKG_METHODS PL_PKG_METHODS
}

#return if already included:
%ifdef BUILD_SETUP_COMPLETE %return

#this is to get later perl operators:
%pragma version 1.98

###########
# note - version is initialized in pkgconfig.defs
# TODO:  initialize these from:  cvs log -h ecdumpImpl.defs
VERSION_STR  = 1.0
VERSION_DATE = 27-Feb-2013
###########

%pragma trim_multiline_rnewline 1

#defaults if not defined by caller:
%ifndef CG_ROOT    CG_ROOT = ./bld
CG_ROOT_BASE       = $CG_ROOT

%ifndef NO_SYMLINKS	NO_SYMLINKS = 0
%ifndef GEN_ONE_MODULE	GEN_ONE_MODULE = 0

LOCAL_INCLUDES =          cgsrc
#this allows us to run in sub-projects:
LOCAL_INCLUDES =          $LOCAL_INCLUDES;..;$CG_ROOT/objects
CG_TEMPLATE_PATH=         $LOCAL_INCLUDES;$CG_TEMPLATE_PATH

SRCROOT =  $SRCROOT:nameof:env
%ifndef SRCROOT %eecho ERROR: SRCROOT must be defined - ABORT
%ifndef SRCROOT %halt 1

TOOLROOT = $TOOLROOT:nameof:env
%ifndef TOOLROOT %eecho ERROR: TOOLROOT must be defined - ABORT
%ifndef TOOLROOT %halt 1

JDBC_CLASSLIB = $TOOLROOT/java/ant/lib

%ifnot $JDBC_CLASSLIB:d  %eecho JDBC_CLASSLIB must be a directory - ABORT
%ifnot $JDBC_CLASSLIB:d  %halt 2

#set the name of final module if we are generating:
%ifndef GEN_ONE_MODULE	GEN_ONE_MODULE=1
%if $GEN_ONE_MODULE	ONE_MODULE = $ECDUMP_PACKAGE.pl

#######
#ecdump packages:
#convention:  _<package> is "full perl path" for package.
#######
ECDUMP_PACKAGE      = ecdump
_ECDUMP_PACKAGE     = ${ECDUMP_PACKAGE}
DEFAULT_PACKAGE      = $_ECDUMP_PACKAGE

ECDUMPIMPL_PACKAGE   = ecdumpImpl
_ECDUMPIMPL_PACKAGE  = ${ECDUMP_PACKAGE}::${ECDUMPIMPL_PACKAGE}

#ecdump configuration parameters:
PKGCONFIG_PACKAGE  = pkgconfig
_PKGCONFIG_PACKAGE = ${ECDUMP_PACKAGE}::${PKGCONFIG_PACKAGE}

######
#sqlpj packages:
######
SQLPJ_PACKAGE      = sqlpj
_SQLPJ_PACKAGE     = ${SQLPJ_PACKAGE}

SQLPJ_IMPL_PACKAGE   = sqlpjImpl
_SQLPJ_IMPL_PACKAGE   = ${SQLPJ_PACKAGE}::${SQLPJ_IMPL_PACKAGE}

SQLPJ_CONFIG_PACKAGE  = pkgconfig
_SQLPJ_CONFIG_PACKAGE = ${SQLPJ_PACKAGE}::${SQLPJ_CONFIG_PACKAGE}

#set default constuctor name:
PL_CONSTRUCTOR_NAME = new

#set global var for generating standard getter/setters:
%readtemplate pl_getset     perl/getset.ptpl
#same again for list value:
%readtemplate pl_getsetlist perl/getsetlist.ptpl

#immutable attributes - with no get prefix:
%readtemplate pl_attr_method     perl/get.ptpl
#same again for list value:
%readtemplate pl_attrlist_method perl/getlist.ptpl

OBJECT_UTILS := << EOF
sub dumpThisObject
{
    my ($aref) = @_;

    for my $kk (keys %$aref) {
        printf STDERR "DUMP kk='%s' aref{%s}='%s'\n", $kk, $kk, defined($$aref{$kk})? $$aref{$kk} : "UNDEF";
    }
}

EOF

#:pl2path            - convert perl package reference to .pl pathname, e.g. Foo::Bar::Impl -> Foo/Bar/Impl.pl
#:pm2path            - convert perl package reference to .pm pathname, e.g. Foo::Bar::Impl -> Foo/Bar/Impl.pm
#:prlpkg2path        - convert perl parent package reference to path, e.g. Foo::Bar -> Foo/Bar
#:path2pm            - convert perl pathname to perl module or package name, e.g.:

generate_a_module := << EOF
#macro to generate a single module and append to single module
{
#%echo generate_a_module module_defs=$module_defs PL_PACKAGE=$PL_PACKAGE GEN_ONE_MODULE=$GEN_ONE_MODULE
    %ifndef  perl_template       perl_template = perl/prlobj.ptpl
    %ifndef  perl_outputfn       perl_outputfn = $_PL_PACKAGE:pm2path

    %ifndef   PL_PACKAGE_PREFIX    PL_PACKAGE_PREFIX = ${DEFAULT_PACKAGE}::
    %include  $module_defs
    %if       $GEN_ONE_MODULE    $perl_template >>    /$ONE_MODULE
    %include  perl/reset_template_vars.ptpl

    %include  $module_defs
    %ifnot    $GEN_ONE_MODULE    $perl_template       lib/$perl_outputfn
    %include  perl/reset_template_vars.ptpl

    %undef  module_defs
    %undef  perl_template
    %undef  perl_outputfn
    %undef  PL_PACKAGE_PREFIX
}
EOF

#tell sub-sections we have been initialized:
BUILD_SETUP_COMPLETE = 1
